Open PicoBlaze Assembler log for program "uart_kcpsm3.psm"
Generated by opbasm v1.3
  Assembled on 2019-06-27T12:05:45
  PicoBlaze-3 mode

  Last occupied address: 3FF hex
  Nominal program memory size: 1K (1024)  address(9:0)
  Actual memory size: 1024
  Occupied memory locations: 510
  Memory locations available: 514
  Scratchpad size: 64


Assembly listing
----------------
000                             ;KCPSM3 Program - Real Time Clock with UART communication.
                                ;
000                             ;Ken Chapman - Xilinx Ltd - October 2003
                                ;
                                ;
000                             ;Port definitions
                                ;
000                             CONSTANT UART_status_port, 01  ;UART status input
000                             CONSTANT tx_half_full, 01      ;  Transmitter     half full - bit0
000                             CONSTANT tx_full, 02           ;    FIFO               full - bit1
000                             CONSTANT rx_half_full, 04      ;  Receiver        half full - bit2
000                             CONSTANT rx_full, 08           ;    FIFO               full - bit3
000                             CONSTANT rx_data_present, 10   ;               data present - bit4
                                ;
000                             CONSTANT UART_read_port, 02    ;UART Rx data input
                                ;
000                             CONSTANT UART_write_port, 08   ;UART Tx data output
                                ;
000                             CONSTANT alarm_port, 00        ;Alarm output
000                             CONSTANT alarm_control, 01     ;     bit0
                                ;
000                             ;Special Register usage
                                ;
000                             NAMEREG sf, UART_data          ;used to pass data to and from the UART
                                ;
000                             NAMEREG se, store_pointer      ;used to pass location of data in scratch pad memory
                                ;
000                             ;Two registers to form a 16-bit counter used to count
000                             ;interrupt pulses generated at 1us intervals.
                                ;
000                             NAMEREG sd, int_counter_lsb    ;lower 8-bits
000                             NAMEREG sc, int_counter_msb    ;upper 8-bits
                                ;
                                ;
000                             ;Scratch Pad Memory Locations
                                ;
                                ;
000                             CONSTANT us_time_stamp_lsb, 00 ;16-bit micro-second time stamp
000                             CONSTANT us_time_stamp_msb, 01
                                ;
000                             CONSTANT us_time_lsb, 02       ;16-bit micro-second real time value
000                             CONSTANT us_time_msb, 03
                                ;
000                             CONSTANT ms_time_lsb, 04       ;16-bit milli-second real time value
000                             CONSTANT ms_time_msb, 05
                                ;
000                             CONSTANT real_time_hours, 06   ;Current clock time
000                             CONSTANT real_time_minutes, 07
000                             CONSTANT real_time_seconds, 08
                                ;
000                             CONSTANT alarm_time_hours, 09  ;Alarm time
000                             CONSTANT alarm_time_minutes, 0A
000                             CONSTANT alarm_time_seconds, 0B
                                ;
000                             CONSTANT alarm_status, 0C      ;Alarm status
000                             CONSTANT alarm_active, 01      ;    bit0 - Alarm is active
000                             CONSTANT alarm_armed, 02       ;    bit1 - Alarm is armed
                                ;
000                             CONSTANT time_preserve0, 10    ;storage for protection of registers
000                             CONSTANT time_preserve1, 11    ;used by the real time clock routine.
000                             CONSTANT time_preserve2, 12
000                             CONSTANT time_preserve3, 13
000                             CONSTANT time_preserve4, 14
000                             CONSTANT time_preserve5, 15
                                ;
000                             ;UART character strings will be stored in scratch pad memory ending in carriage return.
000                             ;A string can be up to 16 characters with the start location defined by this constant.
                                ;
000                             CONSTANT string_start, 20
                                ;
                                ;
000                             ;Initialise the system
                                ;
                                ;
000  00000          cold_start: LOAD s0, 00                    ;clear all time values
001  2E000                      STORE s0, us_time_stamp_lsb
002  2E001                      STORE s0, us_time_stamp_msb
003  2E002                      STORE s0, us_time_lsb
004  2E003                      STORE s0, us_time_msb
005  2E004                      STORE s0, ms_time_lsb
006  2E005                      STORE s0, ms_time_msb
007  2E006                      STORE s0, real_time_hours
008  2E007                      STORE s0, real_time_minutes
009  2E008                      STORE s0, real_time_seconds
00A  2E009                      STORE s0, alarm_time_hours
00B  2E00A                      STORE s0, alarm_time_minutes
00C  2E00B                      STORE s0, alarm_time_seconds
00D  2E00C                      STORE s0, alarm_status         ;clear and disable alarm
00E  300A4                      CALL alarm_drive               ;turn off alarm control output port
00F  00D00                      LOAD int_counter_lsb, 00       ;clear 'us' interrupt counter
010  00C00                      LOAD int_counter_msb, 00
011  3C001                      ENABLE INTERRUPT               ;enable the 1us interrupts
                                ;
                                ;
012                             ;Start of the main program loop.
                                ;
012                             ;A prompt is transmitted to the UART transmitter and then
012                             ;a command can be entered and interpreted.
                                ;
                                ;
012  30115        prompt_input: CALL send_prompt               ;Prompt 'KCPSM3>'
013  300C3                      CALL receive_string            ;obtain input string and maintain the time
                                ;
                                ;
014                             ;Parse the string and perform actions as required
                                ;
                                ;
                                ;
014  00120                      LOAD s1, string_start
015  30091                      CALL fetch_char_from_memory
016  1400D                      COMPARE s0, character_CR       ;carriage return does nothing
017  35012                      JUMP Z, prompt_input
018  14054                      COMPARE s0, character_T        ;start of 'TIME' command?
019  3501E                      JUMP Z, test_for_TIME
01A  14041                      COMPARE s0, character_A        ;start of 'ALARM' command?
01B  35037                      JUMP Z, test_for_ALARM
                                ;
01C                             ;trap other command starts here
                                ;
01C  300ED   bad_input_command: CALL send_Syntax_Error         ;no valid command
01D  35012                      JUMP Z, prompt_input
                                ;
                                ;
01E  30091       test_for_TIME: CALL fetch_char_from_memory
01F  14049                      COMPARE s0, character_I        ;test for rest of 'TIME'
020  3541C                      JUMP NZ, bad_input_command
021  30091                      CALL fetch_char_from_memory
022  1404D                      COMPARE s0, character_M
023  3541C                      JUMP NZ, bad_input_command
024  30091                      CALL fetch_char_from_memory
025  14045                      COMPARE s0, character_E
026  3541C                      JUMP NZ, bad_input_command
027                             ;now have a valid TIME command to process
027  30091                      CALL fetch_char_from_memory
028  1400D                      COMPARE s0, character_CR       ;carriage return means display time
029  3542C                      JUMP NZ, set_time_command
02A  300A8                      CALL transmit_time             ;transmit time to UART
02B  34012                      JUMP prompt_input
02C  14020    set_time_command: COMPARE s0, character_space
02D  3541C                      JUMP NZ, bad_input_command
02E  3006D                      CALL test_time_string          ;interpret 'hh:mm:ss' string
02F  35812                      JUMP C, prompt_input           ;test for invalid input
030  2E606                      STORE s6, real_time_hours      ;set new time into clock
031  2E507                      STORE s5, real_time_minutes
032  2E408                      STORE s4, real_time_seconds
033  2E004                      STORE s0, ms_time_lsb          ;clear 'ms' counter (s0=00)
034  2E005                      STORE s0, ms_time_msb
035  300A8                      CALL transmit_time             ;transmit new time to UART
036  34012                      JUMP prompt_input
                                ;
                                ;
037  30091      test_for_ALARM: CALL fetch_char_from_memory
038  1404C                      COMPARE s0, character_L        ;test for rest of 'ALARM'
039  3541C                      JUMP NZ, bad_input_command
03A  30091                      CALL fetch_char_from_memory
03B  14041                      COMPARE s0, character_A
03C  3541C                      JUMP NZ, bad_input_command
03D  30091                      CALL fetch_char_from_memory
03E  14052                      COMPARE s0, character_R
03F  3541C                      JUMP NZ, bad_input_command
040  30091                      CALL fetch_char_from_memory
041  1404D                      COMPARE s0, character_M
042  3541C                      JUMP NZ, bad_input_command
043                             ;now have a valid ALARM command to process
043  30091                      CALL fetch_char_from_memory
044  1400D                      COMPARE s0, character_CR       ;carriage return means display alarm time
045  35448                      JUMP NZ, set_alarm_command
046  300AC                      CALL transmit_alarm_time       ;transmit time to UART
047  34012                      JUMP prompt_input
048  14020   set_alarm_command: COMPARE s0, character_space    ;test for ON or OFF command
049  3541C                      JUMP NZ, bad_input_command
04A  30091                      CALL fetch_char_from_memory
04B  1404F                      COMPARE s0, character_O
04C  35055                      JUMP Z, set_alarm_on_off
04D  1C101                      SUB s1, 01                     ;move memory pointer back to first character of 'hh:mm:ss' string
04E  3006D                      CALL test_time_string          ;interpret 'hh:mm:ss' string
04F  35812                      JUMP C, prompt_input           ;test for invalid input
050  2E609                      STORE s6, alarm_time_hours     ;set new time into clock
051  2E50A                      STORE s5, alarm_time_minutes
052  2E40B                      STORE s4, alarm_time_seconds
053  300AC                      CALL transmit_alarm_time       ;transmit new alarm time and status
054  34012                      JUMP prompt_input
055  30091    set_alarm_on_off: CALL fetch_char_from_memory
056  1404E                      COMPARE s0, character_N        ;test for 'ON'
057  35460                      JUMP NZ, test_OFF
058  30091                      CALL fetch_char_from_memory
059  1400D                      COMPARE s0, character_CR
05A  3541C                      JUMP NZ, bad_input_command
05B  0600C                      FETCH s0, alarm_status         ;turn alarm on
05C  0C002                      OR s0, alarm_armed
05D  2E00C                      STORE s0, alarm_status
05E  300AC                      CALL transmit_alarm_time       ;transmit alarm time and status
05F  34012                      JUMP prompt_input
060  14046            test_OFF: COMPARE s0, character_F        ;test for for 'OFF'
061  3541C                      JUMP NZ, bad_input_command
062  30091                      CALL fetch_char_from_memory
063  14046                      COMPARE s0, character_F
064  3541C                      JUMP NZ, bad_input_command
065  30091                      CALL fetch_char_from_memory
066  1400D                      COMPARE s0, character_CR
067  3541C                      JUMP NZ, bad_input_command
068  00000                      LOAD s0, 00                    ;turn alarm off and stop an active alarm
069  2E00C                      STORE s0, alarm_status
06A  300A4                      CALL alarm_drive               ;turn off alarm
06B  300AC                      CALL transmit_alarm_time       ;transmit alarm time and status
06C  34012                      JUMP prompt_input
                                ;
                                ;
                                ;
                                ;
06D                             ;Read an 'hh:mm:ss' time string and provide new values.
                                ;
06D                             ;The string must be provided in successive scratch pad memory locations
06D                             ;with the s1 register containing the location of the first character.
                                ;
06D                             ;A correct time specification will result in the return of new values
06D                             ;as follows:-
                                ;
06D                             ;       s6 = hours
06D                             ;       s5 = minutes
06D                             ;       s4 = seconds
                                ;
06D                             ;If the syntax is incorrect or values are not in the correct ranges an
06D                             ;'Invalid Time' message will be transmitted and the CARRY flag will be set
                                ;
06D                             ;Registers used s0, s1, s6, s5 and s4
                                ;
06D  301EC    test_time_string: CALL 2char_to_value            ;obtain hours value
06E  3588B                      JUMP C, invalid_time           ;test for non-decimal characters
06F  01620                      LOAD s6, s2                    ;remember hours
070  18101                      ADD s1, 01                     ;increment memory pointer past hours
071  30091                      CALL fetch_char_from_memory
072  1403A                      COMPARE s0, character_colon    ;test for colon
073  3548B                      JUMP NZ, invalid_time
074  301EC                      CALL 2char_to_value            ;obtain minutes value
075  3588B                      JUMP C, invalid_time           ;test for non-decimal characters
076  01520                      LOAD s5, s2                    ;remember minutes
077  18101                      ADD s1, 01                     ;increment memory pointer past minutes
078  30091                      CALL fetch_char_from_memory
079  1403A                      COMPARE s0, character_colon    ;test for colon
07A  3548B                      JUMP NZ, invalid_time
07B  301EC                      CALL 2char_to_value            ;obtain seconds value
07C  3588B                      JUMP C, invalid_time           ;test for non-decimal characters
07D  01420                      LOAD s4, s2                    ;remember minutes
07E  18101                      ADD s1, 01                     ;increment memory pointer past seconds
07F  30091                      CALL fetch_char_from_memory
080  1400D                      COMPARE s0, character_CR       ;finish with carriage return
081  3548B                      JUMP NZ, invalid_time
082                             ;Have values for hh:mm:ss but need to test if each is valid range.
082  14618                      COMPARE s6, hours_in_a_day
083  35C8B                      JUMP NC, invalid_time
084  1453C                      COMPARE s5, minutes_in_an_hour
085  35C8B                      JUMP NC, invalid_time
086  1443C                      COMPARE s4, seconds_in_a_minute
087  35C8B                      JUMP NC, invalid_time
088  00000                      LOAD s0, 00
089  2000E                      SR0 s0                         ;reset CARRY flag (with s0=0)
08A  2A000                      RETURN                         ;time string was OK
08B  30125        invalid_time: CALL send_Invalid
08C  300E7                      CALL send_space
08D  30134                      CALL send_Time
08E  00001                      LOAD s0, 01
08F  2000E                      SR0 s0                         ;set CARRY flag
090  2A000                      RETURN                         ;time string was bad
                                ;
                                ;
091                             ;Fetch character from memory, convert to upper case
091                             ;and increment memory pointer.
                                ;
091                             ;The memory pointer is provided in register s1.
091                             ;The character obtained is returned in register s0.
                                ;
091                             ;Registers used s0 and s1.
                                ;
091  07010 fetch_char_from_memory: FETCH s0, (s1)                 ;read character
092  301E2                      CALL upper_case                ;convert to upper case
093  18101                      ADD s1, 01                     ;increment memory pointer
094  2A000                      RETURN
                                ;
                                ;
                                ;
095                             ;Read one character from the UART
                                ;
095                             ;Character read will be returned in a register called 'UART_data' and will be
095                             ;echoed to the UART transmitter.
                                ;
095                             ;The routine first tests the receiver FIFO buffer to see if data is present.
095                             ;If the FIFO is empty, the routine waits until there is a character to read.
095                             ;As this could take any amount of time the wait loop includes a call to the
095                             ;subroutine which updates the real time clock.
                                ;
095                             ;Registers used s0 and UART_data
                                ;
095  04001      read_from_UART: INPUT s0, UART_status_port     ;test Rx_FIFO buffer
096  12010                      TEST s0, rx_data_present
097  3549A                      JUMP NZ, read_character
098  30185                      CALL update_time               ;Perform useful operation whilst waiting
099  34095                      JUMP read_from_UART
09A  04F02      read_character: INPUT UART_data, UART_read_port ;read from FIFO
09B  3009D                      CALL send_to_UART              ;echo received character
09C  2A000                      RETURN
                                ;
                                ;
                                ;
09D                             ;Transmit one character to the UART
                                ;
09D                             ;Character supplied in register called 'UART_data'.
                                ;
09D                             ;The routine first tests the transmit FIFO buffer to see if it is full.
09D                             ;If the FIFO is full, the routine waits until there is space which could
09D                             ;be as long as it takes to transmit one complete character.
                                ;
09D                             ;    Baud Rate    Time per Character (10 bits)
09D                             ;      9600           1,024us
09D                             ;     19200             521us
09D                             ;     38400             260us
09D                             ;     57600             174us
09D                             ;    115200              87us
                                ;
09D                             ;Since this is a relatively long duration, the wait loop includes a
09D                             ;call to the subroutine which updates the real time clock.
                                ;
09D                             ;Registers used s0
                                ;
09D  04001        send_to_UART: INPUT s0, UART_status_port     ;test Tx_FIFO buffer
09E  12002                      TEST s0, tx_full
09F  350A2                      JUMP Z, UART_write
0A0  30185                      CALL update_time               ;Perform useful operation whilst waiting
0A1  3409D                      JUMP send_to_UART
0A2  2CF08          UART_write: OUTPUT UART_data, UART_write_port
0A3  2A000                      RETURN
                                ;
                                ;
                                ;
                                ;
0A4                             ;Alarm output
                                ;
0A4                             ;Uses the alarm status scratch pad memory to set or reset the alarm
0A4                             ;control bit on the alarm output port.
                                ;
0A4                             ;Registers used s0
                                ;
0A4  0600C         alarm_drive: FETCH s0, alarm_status         ;read status
0A5  0A001                      AND s0, alarm_active           ;isolate bit0
0A6  2C000                      OUTPUT s0, alarm_port
0A7  2A000                      RETURN
                                ;
                                ;
                                ;
                                ;
                                ;
0A8                             ;Transmit the time to the UART port in the format hh:mm:ss and end
0A8                             ;with a carriage return.
                                ;
0A8                             ;The time to converted must be stored in 3 scratch pad memory locations as
0A8                             ;defined below. A register named 'store_pointer' must provide the address of
0A8                             ;first location.
                                ;
0A8                             ;        Address                Data
                                ;
0A8                             ;     store_pointer      ----> hours
0A8                             ;     store_pointer + 1  ----> minutes
0A8                             ;     store_pointer + 1  ----> seconds
                                ;
0A8                             ;The routine first converts the time into an ASCII string stored in scratch
0A8                             ;pad memory starting at a location specified by a constant named 'string_start'.
0A8                             ;The string will then be transmitted.
                                ;
0A8                             ;Registers used s0, s1, s2, 'store_pointer' and 'UART_data'.
                                ;
0A8  00E06       transmit_time: LOAD store_pointer, real_time_hours ;locate current time in memory
0A9  30160                      CALL time_to_ASCII
0AA  300BC                      CALL transmit_string
0AB  2A000                      RETURN
                                ;
                                ;
0AC                             ;Transmit the alarm time and status to the UART port in the format hh:mm:ss and
0AC                             ;ending with carriage return.
                                ;
0AC                             ;The alarm time to converted must be stored in 3 scratch pad memory locations as
0AC                             ;defined below. A register named 'store_pointer' must provide the address of
0AC                             ;first location.
                                ;
0AC                             ;        Address                Data
                                ;
0AC                             ;     store_pointer      ----> hours
0AC                             ;     store_pointer + 1  ----> minutes
0AC                             ;     store_pointer + 1  ----> seconds
                                ;
0AC                             ;The routine first converts the time into an ASCII string stored in scratch
0AC                             ;pad memory starting at a location specified by a constant named 'string_start'.
0AC                             ;The string will then be transmitted.
                                ;
0AC                             ;Registers used s0, s1, s2, 'store_pointer' and 'UART_data'.
                                ;
0AC  00E09 transmit_alarm_time: LOAD store_pointer, alarm_time_hours ;locate alarm time in memory
0AD  30160                      CALL time_to_ASCII
0AE  300BC                      CALL transmit_string
0AF  3013D                      CALL send_Alarm
0B0  300E7                      CALL send_space
0B1  0600C                      FETCH s0, alarm_status         ;read alarm status
0B2  12001                      TEST s0, alarm_active          ;test for active
0B3  350B6                      JUMP Z, test_armed
0B4  30153                      CALL send_Active
0B5  2A000                      RETURN
0B6  12002          test_armed: TEST s0, alarm_armed           ;test for on
0B7  350BA                      JUMP Z, alarm_is_off
0B8  3014E                      CALL send_ON
0B9  2A000                      RETURN
0BA  30148        alarm_is_off: CALL send_OFF
0BB  2A000                      RETURN
                                ;
                                ;
0BC                             ;Transmit ASCII string to UART
                                ;
0BC                             ;An ASCII string must be provided in scratch pad memory commencing at the
0BC                             ;location specified by a constant named 'string_start'. The string must
0BC                             ;end with a carriage return (0D).
                                ;
0BC                             ;Registers used s1 and 'UART_data'.
0BC                             ;               s0 is then used in subroutine 'send_to_UART'
                                ;
0BC  00120     transmit_string: LOAD s1, string_start          ;locate start of string
0BD  07F10        next_char_tx: FETCH UART_data, (s1)          ;read character from memory
0BE  3009D                      CALL send_to_UART              ;transmit character
0BF  14F0D                      COMPARE UART_data, character_CR ;test for last character
0C0  2B000                      RETURN Z
0C1  18101                      ADD s1, 01                     ;move to next character
0C2  340BD                      JUMP next_char_tx
                                ;
                                ;
0C3                             ;Receive ASCII string from UART
                                ;
0C3                             ;An ASCII string will be read from the UART and stored in scratch pad memory
0C3                             ;commencing at the location specified by a constant named 'string_start'.
0C3                             ;The string will will have a maximum length of 16 characters including a
0C3                             ;carriage return (0D) denoting the end of the string.
                                ;
0C3                             ;As each character is read, it is echoed to the UART transmitter.
0C3                             ;Some minor editing is supported using backspace (BS=08) which is used
0C3                             ;to adjust what is stored in scratch pad memory and adjust the display
0C3                             ;on the terminal screen using characters sent to the UART transmitter.
                                ;
0C3                             ;A test is made for the receiver FIFO becoming full. A full status is treated as
0C3                             ;a potential error situation and will result in a 'Overflow Error' message being
0C3                             ;transmitted to the UART, the receiver FIFO being purged of all data and an
0C3                             ;empty string being stored (carriage return at first location).
                                ;
0C3                             ;Registers used s0, s1, s2 and 'UART_data'.
                                ;
0C3  00120      receive_string: LOAD s1, string_start          ;locate start of string
0C4  01210                      LOAD s2, s1                    ;compute 16 character address
0C5  18210                      ADD s2, 10
0C6  04001   receive_full_test: INPUT s0, UART_status_port     ;test Rx_FIFO buffer for full
0C7  12008                      TEST s0, rx_full
0C8  354DB                      JUMP NZ, read_error
0C9  30095                      CALL read_from_UART            ;obtain and echo character
0CA  2FF10                      STORE UART_data, (s1)          ;write to memory
0CB  14F0D                      COMPARE UART_data, character_CR ;test for end of string
0CC  2B000                      RETURN Z
0CD  14F08                      COMPARE UART_data, character_BS ;test for back space
0CE  350D3                      JUMP Z, BS_edit
0CF  18101                      ADD s1, 01                     ;increment memory pointer
0D0  15120                      COMPARE s1, s2                 ;test for pointer exceeding 16 characters
0D1  354C6                      JUMP NZ, receive_full_test     ;next character
0D2  300EA                      CALL send_backspace            ;hold end of string position on terminal display
0D3  1C101             BS_edit: SUB s1, 01                     ;memory pointer back one
0D4  14120                      COMPARE s1, string_start       ;test for under flow
0D5  358D9                      JUMP C, string_start_again
0D6  300E7                      CALL send_space                ;clear character at current position
0D7  300EA                      CALL send_backspace            ;position cursor
0D8  340C6                      JUMP receive_full_test         ;next character
0D9  30122  string_start_again: CALL send_greater_than         ;restore '>' at prompt
0DA  340C3                      JUMP receive_string            ;begin again
0DB                             ;Receiver buffer overflow condition
0DB  300E4          read_error: CALL send_CR                   ;Transmit error message
0DC  2EF20                      STORE UART_data, string_start  ;empty string in memory (start with CR)
0DD  300FA                      CALL send_Overflow_Error
0DE  300E4                      CALL send_CR
0DF  04001  clear_UART_Rx_loop: INPUT s0, UART_status_port     ;test Rx_FIFO buffer for data
0E0  12010                      TEST s0, rx_data_present
0E1  2B000                      RETURN Z                       ;finish when buffer is empty
0E2  04F02                      INPUT UART_data, UART_read_port ;read from FIFO and ignore
0E3  340DF                      JUMP clear_UART_Rx_loop
                                ;
                                ;
                                ;
0E4                             ;Send Carriage Return to the UART
                                ;
0E4  00F0D             send_CR: LOAD UART_data, character_CR
0E5  3009D                      CALL send_to_UART
0E6  2A000                      RETURN
                                ;
                                ;
                                ;
0E7                             ;Send a space to the UART
                                ;
0E7  00F20          send_space: LOAD UART_data, character_space
0E8  3009D                      CALL send_to_UART
0E9  2A000                      RETURN
                                ;
                                ;
0EA                             ;Send a back space to the UART
                                ;
0EA  00F08      send_backspace: LOAD UART_data, character_BS
0EB  3009D                      CALL send_to_UART
0EC  2A000                      RETURN
                                ;
0ED                             ;Send 'Syntax Error' to the UART
                                ;
0ED  00F53   send_Syntax_Error: LOAD UART_data, character_S
0EE  3009D                      CALL send_to_UART
0EF  00F79                      LOAD UART_data, character_y
0F0  3009D                      CALL send_to_UART
0F1  00F6E                      LOAD UART_data, character_n
0F2  3009D                      CALL send_to_UART
0F3  00F74                      LOAD UART_data, character_t
0F4  3009D                      CALL send_to_UART
0F5  00F61                      LOAD UART_data, character_a
0F6  3009D                      CALL send_to_UART
0F7  00F78                      LOAD UART_data, character_x
0F8  3009D                      CALL send_to_UART
0F9  3410A                      JUMP send_space_Error
                                ;
0FA                             ;Send 'Overflow Error' to the UART
                                ;
0FA  00F4F send_Overflow_Error: LOAD UART_data, character_O
0FB  3009D                      CALL send_to_UART
0FC  00F76                      LOAD UART_data, character_v
0FD  3009D                      CALL send_to_UART
0FE  00F65                      LOAD UART_data, character_e
0FF  3009D                      CALL send_to_UART
100  00F72                      LOAD UART_data, character_r
101  3009D                      CALL send_to_UART
102  00F66                      LOAD UART_data, character_f
103  3009D                      CALL send_to_UART
104  00F6C                      LOAD UART_data, character_l
105  3009D                      CALL send_to_UART
106  00F6F                      LOAD UART_data, character_o
107  3009D                      CALL send_to_UART
108  00F77                      LOAD UART_data, character_w
109  3009D                      CALL send_to_UART
10A  300E7    send_space_Error: CALL send_space
                                ;
10B                             ;Send 'Error' to the UART
                                ;
10B  00F45          send_Error: LOAD UART_data, character_E
10C  3009D                      CALL send_to_UART
10D  00F72                      LOAD UART_data, character_r
10E  3009D                      CALL send_to_UART
10F  3009D                      CALL send_to_UART
110  00F6F                      LOAD UART_data, character_o
111  3009D                      CALL send_to_UART
112  00F72                      LOAD UART_data, character_r
113  3009D                      CALL send_to_UART
114  2A000                      RETURN
                                ;
115                             ;Send 'KCPSM3>' prompt to the UART
                                ;
115  300E4         send_prompt: CALL send_CR                   ;start new line
116  00F4B                      LOAD UART_data, character_K
117  3009D                      CALL send_to_UART
118  00F43                      LOAD UART_data, character_C
119  3009D                      CALL send_to_UART
11A  00F50                      LOAD UART_data, character_P
11B  3009D                      CALL send_to_UART
11C  00F53                      LOAD UART_data, character_S
11D  3009D                      CALL send_to_UART
11E  00F4D                      LOAD UART_data, character_M
11F  3009D                      CALL send_to_UART
120  00F33                      LOAD UART_data, character_3
121  3009D                      CALL send_to_UART
                                ;
122                             ;Send '>' character to the UART
                                ;
122  00F3E   send_greater_than: LOAD UART_data, character_greater_than
123  3009D                      CALL send_to_UART
124  2A000                      RETURN
                                ;
125                             ;Send 'Invalid' string to the UART
                                ;
125  00F49        send_Invalid: LOAD UART_data, character_I
126  3009D                      CALL send_to_UART
127  00F6E                      LOAD UART_data, character_n
128  3009D                      CALL send_to_UART
129  00F76                      LOAD UART_data, character_v
12A  3009D                      CALL send_to_UART
12B  00F61                      LOAD UART_data, character_a
12C  3009D                      CALL send_to_UART
12D  00F6C                      LOAD UART_data, character_l
12E  3009D                      CALL send_to_UART
12F  00F69                      LOAD UART_data, character_i
130  3009D                      CALL send_to_UART
131  00F64                      LOAD UART_data, character_d
132  3009D                      CALL send_to_UART
133  2A000                      RETURN
                                ;
134                             ;Send 'Time' string to the UART
                                ;
134  00F54           send_Time: LOAD UART_data, character_T
135  3009D                      CALL send_to_UART
136  00F69                      LOAD UART_data, character_i
137  3009D                      CALL send_to_UART
138  00F6D                      LOAD UART_data, character_m
139  3009D                      CALL send_to_UART
13A  00F65                      LOAD UART_data, character_e
13B  3009D                      CALL send_to_UART
13C  2A000                      RETURN
                                ;
13D                             ;Send 'Alarm' string to the UART
                                ;
13D  00F41          send_Alarm: LOAD UART_data, character_A
13E  3009D                      CALL send_to_UART
13F  00F6C                      LOAD UART_data, character_l
140  3009D                      CALL send_to_UART
141  00F61                      LOAD UART_data, character_a
142  3009D                      CALL send_to_UART
143  00F72                      LOAD UART_data, character_r
144  3009D                      CALL send_to_UART
145  00F6D                      LOAD UART_data, character_m
146  3009D                      CALL send_to_UART
147  2A000                      RETURN
                                ;
148                             ;Send 'OFF' string to the UART
                                ;
148  00F4F            send_OFF: LOAD UART_data, character_O
149  3009D                      CALL send_to_UART
14A  00F46                      LOAD UART_data, character_F
14B  3009D                      CALL send_to_UART
14C  3009D                      CALL send_to_UART
14D  2A000                      RETURN
                                ;
14E                             ;Send 'ON' string to the UART
                                ;
14E  00F4F             send_ON: LOAD UART_data, character_O
14F  3009D                      CALL send_to_UART
150  00F4E                      LOAD UART_data, character_N
151  3009D                      CALL send_to_UART
152  2A000                      RETURN
                                ;
153                             ;Send 'Active' string to the UART
                                ;
153  00F41         send_Active: LOAD UART_data, character_A
154  3009D                      CALL send_to_UART
155  00F63                      LOAD UART_data, character_c
156  3009D                      CALL send_to_UART
157  00F74                      LOAD UART_data, character_t
158  3009D                      CALL send_to_UART
159  00F69                      LOAD UART_data, character_i
15A  3009D                      CALL send_to_UART
15B  00F76                      LOAD UART_data, character_v
15C  3009D                      CALL send_to_UART
15D  00F65                      LOAD UART_data, character_e
15E  3009D                      CALL send_to_UART
15F  2A000                      RETURN
                                ;
                                ;
160                             ;Convert time to ASCII string in scratch pad memory.
                                ;
160                             ;The time to converted must be stored in 3 scratch pad memory locations as
160                             ;defined below. A register named 'store_pointer' must provide the address of
160                             ;first location.
                                ;
160                             ;        Address                Data
                                ;
160                             ;     store_pointer      ----> hours
160                             ;     store_pointer + 1  ----> minutes
160                             ;     store_pointer + 1  ----> seconds
                                ;
160                             ;The resulting ASCII string will be stored in scratch pad memory starting at
160                             ;a location specified by a constant named 'string_start'. The string will
160                             ;take the format hh:mm:ss and end with a carriage return.
                                ;
160                             ;Registers used s0, s1, s2 and 'store_pointer'.
                                ;
160  00220       time_to_ASCII: LOAD s2, string_start          ;location for string
161  070E0                      FETCH s0, (store_pointer)      ;read hours value
162  3017E                      CALL decimal_to_ASCII          ;convert to ASCII
163  2F120                      STORE s1, (s2)                 ;write hours to string
164  18201                      ADD s2, 01
165  2F020                      STORE s0, (s2)
166  18201                      ADD s2, 01
167  0003A                      LOAD s0, character_colon       ;write ':' to string
168  2F020                      STORE s0, (s2)
169  18201                      ADD s2, 01
16A  18E01                      ADD store_pointer, 01          ;move to minutes
16B  070E0                      FETCH s0, (store_pointer)      ;read minutes value
16C  3017E                      CALL decimal_to_ASCII          ;convert to ASCII
16D  2F120                      STORE s1, (s2)                 ;write minutes to string
16E  18201                      ADD s2, 01
16F  2F020                      STORE s0, (s2)
170  18201                      ADD s2, 01
171  0003A                      LOAD s0, character_colon       ;write ':' to string
172  2F020                      STORE s0, (s2)
173  18201                      ADD s2, 01
174  18E01                      ADD store_pointer, 01          ;move to seconds
175  070E0                      FETCH s0, (store_pointer)      ;read seconds value
176  3017E                      CALL decimal_to_ASCII          ;convert to ASCII
177  2F120                      STORE s1, (s2)                 ;write seconds to string
178  18201                      ADD s2, 01
179  2F020                      STORE s0, (s2)
17A  18201                      ADD s2, 01
17B  0000D                      LOAD s0, character_CR          ;finish string with carriage return
17C  2F020                      STORE s0, (s2)
17D  2A000                      RETURN
                                ;
17E                             ;Convert value provided in register s0 into ASCII characters
                                ;
17E                             ;The value provided must in the range 0 to 99 and will be converted into
17E                             ;two ASCII characters.
17E                             ;     The number of 'tens' will be representd by an ASCII character returned in register s1.
17E                             ;     The number of 'units' will be representd by an ASCII character returned in register s0.
                                ;
17E                             ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
17E                             ;the actual decimal value.
                                ;
17E                             ;Registers used s0 and s1.
                                ;
17E  00130    decimal_to_ASCII: LOAD s1, 30                    ;load 'tens' counter with ASCII for '0'
17F  18101        test_for_ten: ADD s1, 01                     ;increment 'tens' value
180  1C00A                      SUB s0, 0A                     ;try to subtract 10 from the supplied value
181  35D7F                      JUMP NC, test_for_ten          ;repeat if subtraction was possible without underflow.
182  1C101                      SUB s1, 01                     ;'tens' value one less ten due to underflow
183  1803A                      ADD s0, 3A                     ;restore units value (the remainder) and convert to ASCII
184  2A000                      RETURN
                                ;
                                ;
                                ;
                                ;
185                             ;Real Time Clock
                                ;
185                             ;Uses the 1us interrupt counter [int_counter_msb,int_counter_lsb] to determine how many
185                             ;micro-seconds have elapsed since the last update. This allows for just over 65ms between
185                             ;updates. Complete multiples of 1000us are used to update a 16-bit milli-second counter held
185                             ;in scratch pad memory locations [ms_time_stamp_msb,ms_time_stamp_msb] which in turn
185                             ;is used to update the real time hours, minutes and seconds clock held in scratch pad
185                             ;memory locations 'real_time_hours', 'real_time_minutes' and 'real_time_seconds'.
                                ;
185                             ;The routine uses default register names s0,s1,s2,s3,s4,s5. These are preserved in scratch pad
185                             ;memory during the routine and restored before returning.
                                ;
185                             ;Useful constants for real time clock operations
                                ;
185                             CONSTANT count_1000_lsb, E8    ;lower 8-bits of 1000 count value
185                             CONSTANT count_1000_msb, 03    ;upper 8-bits of 1000 count value
185                             CONSTANT hours_in_a_day, 18    ;24 hours in a day
185                             CONSTANT minutes_in_an_hour, 3C ;60 minutes in an hour
185                             CONSTANT seconds_in_a_minute, 3C ;60 seconds in a minute
                                ;
185  2E010         update_time: STORE s0, time_preserve0       ;preserve contents of registers used during routine
186  2E111                      STORE s1, time_preserve1
187  2E212                      STORE s2, time_preserve2
188  2E313                      STORE s3, time_preserve3
189  2E414                      STORE s4, time_preserve4
18A  2E515                      STORE s5, time_preserve5
                                ;
18B  06200                      FETCH s2, us_time_stamp_lsb    ;read the previous 'us' time stamp into [s3,s2]
18C  06301                      FETCH s3, us_time_stamp_msb
18D  3C000                      DISABLE INTERRUPT              ;Read and store current 'us' time stamp provided by the interrupt
18E  2ED00                      STORE int_counter_lsb, us_time_stamp_lsb ;counter. Interrupts are disabled to ensure that both bytes relate
18F  2EC01                      STORE int_counter_msb, us_time_stamp_msb ;to the same count value.
190  3C001                      ENABLE INTERRUPT
191  06400                      FETCH s4, us_time_stamp_lsb    ;read the new 'us' time stamp in [s5,s4]
192  06501                      FETCH s5, us_time_stamp_msb    ;
193  1D420                      SUB s4, s2                     ;calculate 'us' time difference [s5,s4] = [s5,s4] - [s3,s2]
194  1F530                      SUBCY s5, s3                   ;   (This works correctly even if counter has rolled over)
195  06202                      FETCH s2, us_time_lsb          ;read current 'us' time into [s3,s2]
196  06303                      FETCH s3, us_time_msb
197  19240                      ADD s2, s4                     ;add on the elapsed 'us' value [s3,s2] = [s3,s2] + [s5,s4]
198  1B350                      ADDCY s3, s5
199                             ;determine how many 1000us (1ms) units there are (if any) in current 'us' time
199  00000                      LOAD s0, 00                    ;reset 'ms' counter
19A  1C2E8         test_1000us: SUB s2, count_1000_lsb         ;subtract 1000 from [s3,s2]
19B  1E303                      SUBCY s3, count_1000_msb
19C  3599F                      JUMP C, store_us_time          ;Carry indicates [s3,s2] was less than 1000us
19D  18001                      ADD s0, 01                     ;increment 'ms' elapsed because [s3,s2] was more or equal to 1000us
19E  3419A                      JUMP test_1000us               ;repeat to see if more than 1ms has elapsed
19F  182E8       store_us_time: ADD s2, count_1000_lsb         ;add 1000 to restore 'us' value
1A0  1A303                      ADDCY s3, count_1000_msb
1A1  2E202                      STORE s2, us_time_lsb          ;store the current value of 'us'
1A2  2E303                      STORE s3, us_time_msb
1A3                             ;s0 holds the number of 'ms' elapsed since last update (if any).
1A3  06204                      FETCH s2, ms_time_lsb          ;read current 'ms' time into [s3,s2]
1A4  06305                      FETCH s3, ms_time_msb
1A5  19200                      ADD s2, s0                     ;add on the elapsed 'ms' value [s3,s2] = [s3,s2] + s0
1A6  1A300                      ADDCY s3, 00
1A7                             ;determine if there are now more than 1000ms to form 1 second.
1A7  00000                      LOAD s0, 00                    ;reset 'second' counter
1A8  1C2E8                      SUB s2, count_1000_lsb         ;subtract 1000 from [s3,s2]
1A9  1E303                      SUBCY s3, count_1000_msb
1AA  359AD                      JUMP C, restore_ms_time        ;Carry indicates [s3,s2] was less than 1000ms
1AB  18001                      ADD s0, 01                     ;increment 'second' elapsed because [s3,s2] was more or equal to 1000ms
1AC  341AF                      JUMP store_ms_time             ;new value of 'ms' is remainder of subtraction
1AD  182E8     restore_ms_time: ADD s2, count_1000_lsb         ;add 1000 to restore 'ms' value
1AE  1A303                      ADDCY s3, count_1000_msb
1AF  2E204       store_ms_time: STORE s2, ms_time_lsb          ;store the current value of 'ms'
1B0  2E305                      STORE s3, ms_time_msb
1B1                             ;s0 currently determines if one second needs to be added to the hh:mm:ss clock time
1B1  06108                      FETCH s1, real_time_seconds    ;read seconds
1B2  19100                      ADD s1, s0                     ;add one second if required by s0
1B3  1413C                      COMPARE s1, seconds_in_a_minute ;test for 1 minute
1B4  351B7                      JUMP Z, inc_minutes
1B5  2E108                      STORE s1, real_time_seconds    ;store updated seconds
1B6  341C9                      JUMP time_update_complete
1B7  00100         inc_minutes: LOAD s1, 00                    ;seconds become zero
1B8  2E108                      STORE s1, real_time_seconds
1B9  06107                      FETCH s1, real_time_minutes    ;read minutes
1BA  18101                      ADD s1, 01                     ;increment minutes
1BB  1413C                      COMPARE s1, minutes_in_an_hour ;test for 1 hour
1BC  351BF                      JUMP Z, inc_hours
1BD  2E107                      STORE s1, real_time_minutes    ;store updated minutes
1BE  341C9                      JUMP time_update_complete
1BF  00100           inc_hours: LOAD s1, 00                    ;minutes become zero
1C0  2E107                      STORE s1, real_time_minutes
1C1  06106                      FETCH s1, real_time_hours      ;read hours
1C2  18101                      ADD s1, 01                     ;increment hours
1C3  14118                      COMPARE s1, hours_in_a_day     ;test for 24 hours
1C4  351C7                      JUMP Z, reset_hours
1C5  2E106                      STORE s1, real_time_hours      ;store updated hours
1C6  341C9                      JUMP time_update_complete
1C7  00100         reset_hours: LOAD s1, 00                    ;hours become zero
1C8  2E106                      STORE s1, real_time_hours
                                ;
1C9                             ;With the time updated, there is then a test for time=alarm time
                                ;
1C9  06006 time_update_complete: FETCH s0, real_time_hours
1CA  06109                      FETCH s1, alarm_time_hours     ;compare hours
1CB  15010                      COMPARE s0, s1
1CC  355DB                      JUMP NZ, finish_update
1CD  06007                      FETCH s0, real_time_minutes    ;compare minutes
1CE  0610A                      FETCH s1, alarm_time_minutes
1CF  15010                      COMPARE s0, s1
1D0  355DB                      JUMP NZ, finish_update
1D1  06008                      FETCH s0, real_time_seconds    ;compare seconds
1D2  0610B                      FETCH s1, alarm_time_seconds
1D3  15010                      COMPARE s0, s1
1D4  355DB                      JUMP NZ, finish_update
1D5  0600C                      FETCH s0, alarm_status         ;test if alarm is turned on
1D6  12002                      TEST s0, alarm_armed
1D7  351DB                      JUMP Z, finish_update          ;alarm was off
1D8  0C001                      OR s0, alarm_active            ;activate alarm
1D9  2E00C                      STORE s0, alarm_status
1DA  300A4                      CALL alarm_drive
1DB  06010       finish_update: FETCH s0, time_preserve0       ;restore the register contents
1DC  06111                      FETCH s1, time_preserve1
1DD  06212                      FETCH s2, time_preserve2
1DE  06313                      FETCH s3, time_preserve3
1DF  06414                      FETCH s4, time_preserve4
1E0  06515                      FETCH s5, time_preserve5
1E1  2A000                      RETURN
                                ;
1E2                             ;Convert character to upper case
                                ;
1E2                             ;The character supplied in register s0.
1E2                             ;If the character is in the range 'a' to 'z', it is converted
1E2                             ;to the equivalent upper case character in the range 'A' to 'Z'.
1E2                             ;All other characters remain unchanged.
                                ;
1E2                             ;Registers used s0.
                                ;
1E2  14061          upper_case: COMPARE s0, 61                 ;eliminate character codes below 'a' (61 hex)
1E3  2B800                      RETURN C
1E4  1407B                      COMPARE s0, 7B                 ;eliminate character codes above 'z' (7A hex)
1E5  2BC00                      RETURN NC
1E6  0A0DF                      AND s0, DF                     ;mask bit5 to convert to upper case
1E7  2A000                      RETURN
                                ;
                                ;
1E8                             ;Convert character '0' to '9' to numerical value in range 0 to 9
                                ;
1E8                             ;The character supplied in register s0. If the character is in the
1E8                             ;range '0' to '9', it is converted to the equivalent decimal value.
1E8                             ;Characters not in the range '0' to '9' are signified by the return
1E8                             ;with the CARRY flag set.
                                ;
1E8                             ;Registers used s0.
                                ;
1E8  180C6      1char_to_value: ADD s0, C6                     ;reject character codes above '9' (39 hex)
1E9  2B800                      RETURN C                       ;carry flag is set
1EA  1C0F6                      SUB s0, F6                     ;reject character codes below '0' (30 hex)
1EB  2A000                      RETURN                         ;carry is set if value not in range
                                ;
                                ;
1EC                             ;Determine the numerical value of a two character decimal string held in
1EC                             ;scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
                                ;
1EC                             ;The string must be stored as in two consecutive memory locations and the
1EC                             ;location of the first (tens) character supplied in the s1 register.
1EC                             ;The result is provided in register s2. Strings not using characters in the
1EC                             ;range '0' to '9' are signified by the return with the CARRY flag set.
                                ;
1EC                             ;Registers used s0, s1 and s2.
                                ;
1EC  07010      2char_to_value: FETCH s0, (s1)                 ;read 'tens' character
1ED  301E8                      CALL 1char_to_value            ;convert to numerical value
1EE  2B800                      RETURN C                       ;bad character - CARRY set
1EF  01200                      LOAD s2, s0
1F0  20206                      SL0 s2                         ;multiply 'tens' value by 10 (0A hex)
1F1  20206                      SL0 s2
1F2  19200                      ADD s2, s0
1F3  20206                      SL0 s2
1F4  18101                      ADD s1, 01                     ;read 'units' character
1F5  07010                      FETCH s0, (s1)
1F6  301E8                      CALL 1char_to_value            ;convert to numerical value
1F7  2B800                      RETURN C                       ;bad character - CARRY set
1F8  19200                      ADD s2, s0                     ;add units to result and clear CARRY flag
1F9  2A000                      RETURN
                                ;
                                ;
3FC                             ;Interrupt service routine (ISR)
                                ;
3FC                             ;The interrupt is used to increment a 16-bit counter formed with two registers
3FC                             ;called [int_counter_msb,int_counter_lsb]. This provides a count of the number
3FC                             ;of micro-seconds elapsed. The counter is 'free running' in that it will count
3FC                             ;up to 65,535 and then roll over to zero. The count value is then used in other
3FC                             ;parts of the program as required and where it is less time critical.
                                ;
3FC                             ;The ISR only uses the specified counter registers
                                ;
3FC                             ADDRESS 3FC
3FC  18D01                 ISR: ADD int_counter_lsb, 01        ;add 1us to 16-bit counter
3FD  1AC00                      ADDCY int_counter_msb, 00
3FE  38001                      RETURNI ENABLE
                                ;
3FF                             ;Interrupt vector
                                ;
3FF                             ADDRESS 3FF
3FF  343FC                      JUMP ISR
                                ;
                                ;
400                             ;Useful constants
                                ;
                                ;
400                             ;ASCII table
                                ;
400                             CONSTANT character_a, 61
400                             CONSTANT character_b, 62
400                             CONSTANT character_c, 63
400                             CONSTANT character_d, 64
400                             CONSTANT character_e, 65
400                             CONSTANT character_f, 66
400                             CONSTANT character_g, 67
400                             CONSTANT character_h, 68
400                             CONSTANT character_i, 69
400                             CONSTANT character_j, 6A
400                             CONSTANT character_k, 6B
400                             CONSTANT character_l, 6C
400                             CONSTANT character_m, 6D
400                             CONSTANT character_n, 6E
400                             CONSTANT character_o, 6F
400                             CONSTANT character_p, 70
400                             CONSTANT character_q, 71
400                             CONSTANT character_r, 72
400                             CONSTANT character_s, 73
400                             CONSTANT character_t, 74
400                             CONSTANT character_u, 75
400                             CONSTANT character_v, 76
400                             CONSTANT character_w, 77
400                             CONSTANT character_x, 78
400                             CONSTANT character_y, 79
400                             CONSTANT character_z, 7A
400                             CONSTANT character_A, 41
400                             CONSTANT character_B, 42
400                             CONSTANT character_C, 43
400                             CONSTANT character_D, 44
400                             CONSTANT character_E, 45
400                             CONSTANT character_F, 46
400                             CONSTANT character_G, 47
400                             CONSTANT character_H, 48
400                             CONSTANT character_I, 49
400                             CONSTANT character_J, 4A
400                             CONSTANT character_K, 4B
400                             CONSTANT character_L, 4C
400                             CONSTANT character_M, 4D
400                             CONSTANT character_N, 4E
400                             CONSTANT character_O, 4F
400                             CONSTANT character_P, 50
400                             CONSTANT character_Q, 51
400                             CONSTANT character_R, 52
400                             CONSTANT character_S, 53
400                             CONSTANT character_T, 54
400                             CONSTANT character_U, 55
400                             CONSTANT character_V, 56
400                             CONSTANT character_W, 57
400                             CONSTANT character_X, 58
400                             CONSTANT character_Y, 59
400                             CONSTANT character_Z, 5A
400                             CONSTANT character_0, 30
400                             CONSTANT character_1, 31
400                             CONSTANT character_2, 32
400                             CONSTANT character_3, 33
400                             CONSTANT character_4, 34
400                             CONSTANT character_5, 35
400                             CONSTANT character_6, 36
400                             CONSTANT character_7, 37
400                             CONSTANT character_8, 38
400                             CONSTANT character_9, 39
400                             CONSTANT character_colon, 3A
400                             CONSTANT character_semi_colon, 3B
400                             CONSTANT character_less_than, 3C
400                             CONSTANT character_greater_than, 3E
400                             CONSTANT character_equals, 3D
400                             CONSTANT character_space, 20
400                             CONSTANT character_CR, 0D      ;carriage return
400                             CONSTANT character_question, 3F ;'?'
400                             CONSTANT character_dollar, 24
400                             CONSTANT character_BS, 08      ;Back Space command character
                                ;

All unused memory locations contain zero (equivalent to "LOAD s0, 00")


PSM files that have been assembled
----------------------------------
    /home/paul/Documents/Laboratory_reports/PUR/PUR_Project/PUR_Project/Software/uart_kcpsm3.psm


List of defined constants
-------------------------
    CONSTANT name           Value  Source PSM file
 ----------------           -----  ---------------
    BEL                     07
    BS                      08
    CR                      0D
    DCS                     90
    DEL                     7F
    ESC                     1B
    HT                      09
    LF                      0A
    NUL                     00
    ST                      9C
    UART_read_port          02     uart_kcpsm3.psm
    UART_status_port        01     uart_kcpsm3.psm
    UART_write_port         08     uart_kcpsm3.psm
    VT                      0B
    alarm_active            01     uart_kcpsm3.psm
    alarm_armed             02     uart_kcpsm3.psm
 *  alarm_control           01     uart_kcpsm3.psm
    alarm_port              00     uart_kcpsm3.psm
    alarm_status            0C     uart_kcpsm3.psm
    alarm_time_hours        09     uart_kcpsm3.psm
    alarm_time_minutes      0A     uart_kcpsm3.psm
    alarm_time_seconds      0B     uart_kcpsm3.psm
 *  character_0             30     uart_kcpsm3.psm
 *  character_1             31     uart_kcpsm3.psm
 *  character_2             32     uart_kcpsm3.psm
    character_3             33     uart_kcpsm3.psm
 *  character_4             34     uart_kcpsm3.psm
 *  character_5             35     uart_kcpsm3.psm
 *  character_6             36     uart_kcpsm3.psm
 *  character_7             37     uart_kcpsm3.psm
 *  character_8             38     uart_kcpsm3.psm
 *  character_9             39     uart_kcpsm3.psm
    character_A             41     uart_kcpsm3.psm
 *  character_B             42     uart_kcpsm3.psm
    character_BS            08     uart_kcpsm3.psm
    character_C             43     uart_kcpsm3.psm
    character_CR            0D     uart_kcpsm3.psm
 *  character_D             44     uart_kcpsm3.psm
    character_E             45     uart_kcpsm3.psm
    character_F             46     uart_kcpsm3.psm
 *  character_G             47     uart_kcpsm3.psm
 *  character_H             48     uart_kcpsm3.psm
    character_I             49     uart_kcpsm3.psm
 *  character_J             4A     uart_kcpsm3.psm
    character_K             4B     uart_kcpsm3.psm
    character_L             4C     uart_kcpsm3.psm
    character_M             4D     uart_kcpsm3.psm
    character_N             4E     uart_kcpsm3.psm
    character_O             4F     uart_kcpsm3.psm
    character_P             50     uart_kcpsm3.psm
 *  character_Q             51     uart_kcpsm3.psm
    character_R             52     uart_kcpsm3.psm
    character_S             53     uart_kcpsm3.psm
    character_T             54     uart_kcpsm3.psm
 *  character_U             55     uart_kcpsm3.psm
 *  character_V             56     uart_kcpsm3.psm
 *  character_W             57     uart_kcpsm3.psm
 *  character_X             58     uart_kcpsm3.psm
 *  character_Y             59     uart_kcpsm3.psm
 *  character_Z             5A     uart_kcpsm3.psm
    character_a             61     uart_kcpsm3.psm
 *  character_b             62     uart_kcpsm3.psm
    character_c             63     uart_kcpsm3.psm
    character_colon         3A     uart_kcpsm3.psm
    character_d             64     uart_kcpsm3.psm
 *  character_dollar        24     uart_kcpsm3.psm
    character_e             65     uart_kcpsm3.psm
 *  character_equals        3D     uart_kcpsm3.psm
    character_f             66     uart_kcpsm3.psm
 *  character_g             67     uart_kcpsm3.psm
    character_greater_than  3E     uart_kcpsm3.psm
 *  character_h             68     uart_kcpsm3.psm
    character_i             69     uart_kcpsm3.psm
 *  character_j             6A     uart_kcpsm3.psm
 *  character_k             6B     uart_kcpsm3.psm
    character_l             6C     uart_kcpsm3.psm
 *  character_less_than     3C     uart_kcpsm3.psm
    character_m             6D     uart_kcpsm3.psm
    character_n             6E     uart_kcpsm3.psm
    character_o             6F     uart_kcpsm3.psm
 *  character_p             70     uart_kcpsm3.psm
 *  character_q             71     uart_kcpsm3.psm
 *  character_question      3F     uart_kcpsm3.psm
    character_r             72     uart_kcpsm3.psm
 *  character_s             73     uart_kcpsm3.psm
 *  character_semi_colon    3B     uart_kcpsm3.psm
    character_space         20     uart_kcpsm3.psm
    character_t             74     uart_kcpsm3.psm
 *  character_u             75     uart_kcpsm3.psm
    character_v             76     uart_kcpsm3.psm
    character_w             77     uart_kcpsm3.psm
    character_x             78     uart_kcpsm3.psm
    character_y             79     uart_kcpsm3.psm
 *  character_z             7A     uart_kcpsm3.psm
    count_1000_lsb          E8     uart_kcpsm3.psm
    count_1000_msb          03     uart_kcpsm3.psm
    datestamp_day           1B
    datestamp_month         06
    datestamp_year          13
    hours_in_a_day          18     uart_kcpsm3.psm
    minutes_in_an_hour      3C     uart_kcpsm3.psm
    ms_time_lsb             04     uart_kcpsm3.psm
    ms_time_msb             05     uart_kcpsm3.psm
    real_time_hours         06     uart_kcpsm3.psm
    real_time_minutes       07     uart_kcpsm3.psm
    real_time_seconds       08     uart_kcpsm3.psm
    rx_data_present         10     uart_kcpsm3.psm
    rx_full                 08     uart_kcpsm3.psm
 *  rx_half_full            04     uart_kcpsm3.psm
    seconds_in_a_minute     3C     uart_kcpsm3.psm
    string_start            20     uart_kcpsm3.psm
    time_preserve0          10     uart_kcpsm3.psm
    time_preserve1          11     uart_kcpsm3.psm
    time_preserve2          12     uart_kcpsm3.psm
    time_preserve3          13     uart_kcpsm3.psm
    time_preserve4          14     uart_kcpsm3.psm
    time_preserve5          15     uart_kcpsm3.psm
    timestamp_hours         0C
    timestamp_minutes       05
    timestamp_seconds       2D
    tx_full                 02     uart_kcpsm3.psm
 *  tx_half_full            01     uart_kcpsm3.psm
    us_time_lsb             02     uart_kcpsm3.psm
    us_time_msb             03     uart_kcpsm3.psm
    us_time_stamp_lsb       00     uart_kcpsm3.psm
    us_time_stamp_msb       01     uart_kcpsm3.psm

       * Unreferenced constant(s)


  No tables defined


List of text strings
--------------------
    STRING name  Value          Source PSM file
 --------------  -----          ---------------
    datestamp$   "27 Jun 2019"
    timestamp$   "12:05:45"


List of line labels
-------------------
    Label                   Addr  Source PSM file
 --------                   ----  ---------------
    1char_to_value          1E8   uart_kcpsm3.psm
    2char_to_value          1EC   uart_kcpsm3.psm
    BS_edit                 0D3   uart_kcpsm3.psm
    ISR                     3FC   uart_kcpsm3.psm
    UART_write              0A2   uart_kcpsm3.psm
    alarm_drive             0A4   uart_kcpsm3.psm
    alarm_is_off            0BA   uart_kcpsm3.psm
    bad_input_command       01C   uart_kcpsm3.psm
    clear_UART_Rx_loop      0DF   uart_kcpsm3.psm
 *  cold_start              000   uart_kcpsm3.psm
    decimal_to_ASCII        17E   uart_kcpsm3.psm
    fetch_char_from_memory  091   uart_kcpsm3.psm
    finish_update           1DB   uart_kcpsm3.psm
    inc_hours               1BF   uart_kcpsm3.psm
    inc_minutes             1B7   uart_kcpsm3.psm
    invalid_time            08B   uart_kcpsm3.psm
    next_char_tx            0BD   uart_kcpsm3.psm
    prompt_input            012   uart_kcpsm3.psm
    read_character          09A   uart_kcpsm3.psm
    read_error              0DB   uart_kcpsm3.psm
    read_from_UART          095   uart_kcpsm3.psm
    receive_full_test       0C6   uart_kcpsm3.psm
    receive_string          0C3   uart_kcpsm3.psm
    reset_hours             1C7   uart_kcpsm3.psm
    restore_ms_time         1AD   uart_kcpsm3.psm
    send_Active             153   uart_kcpsm3.psm
    send_Alarm              13D   uart_kcpsm3.psm
    send_CR                 0E4   uart_kcpsm3.psm
 *  send_Error              10B   uart_kcpsm3.psm
    send_Invalid            125   uart_kcpsm3.psm
    send_OFF                148   uart_kcpsm3.psm
    send_ON                 14E   uart_kcpsm3.psm
    send_Overflow_Error     0FA   uart_kcpsm3.psm
    send_Syntax_Error       0ED   uart_kcpsm3.psm
    send_Time               134   uart_kcpsm3.psm
    send_backspace          0EA   uart_kcpsm3.psm
    send_greater_than       122   uart_kcpsm3.psm
    send_prompt             115   uart_kcpsm3.psm
    send_space              0E7   uart_kcpsm3.psm
    send_space_Error        10A   uart_kcpsm3.psm
    send_to_UART            09D   uart_kcpsm3.psm
    set_alarm_command       048   uart_kcpsm3.psm
    set_alarm_on_off        055   uart_kcpsm3.psm
    set_time_command        02C   uart_kcpsm3.psm
    store_ms_time           1AF   uart_kcpsm3.psm
    store_us_time           19F   uart_kcpsm3.psm
    string_start_again      0D9   uart_kcpsm3.psm
    test_1000us             19A   uart_kcpsm3.psm
    test_OFF                060   uart_kcpsm3.psm
    test_armed              0B6   uart_kcpsm3.psm
    test_for_ALARM          037   uart_kcpsm3.psm
    test_for_TIME           01E   uart_kcpsm3.psm
    test_for_ten            17F   uart_kcpsm3.psm
    test_time_string        06D   uart_kcpsm3.psm
    time_to_ASCII           160   uart_kcpsm3.psm
    time_update_complete    1C9   uart_kcpsm3.psm
    transmit_alarm_time     0AC   uart_kcpsm3.psm
    transmit_string         0BC   uart_kcpsm3.psm
    transmit_time           0A8   uart_kcpsm3.psm
    update_time             185   uart_kcpsm3.psm
    upper_case              1E2   uart_kcpsm3.psm

       * Unreferenced label(s)


List of pragma blocks
---------------------
   Name  Addr range  Value
   ----  ----------  -----


Instruction usage statistics
----------------------------
   Instruction  Instances
   -----------  ---------
   ADD          33
   ADDCY        5
   AND          2
   CALL         123
   COMPARE      39
   DISABLE      1
   ENABLE       2
   FETCH        34
   INPUT        6
   JUMP         69
   LOAD         80
   OR           2
   OUTPUT       2
   RETURN       35
   RETURNI      1
   RL           -
   RR           -
   SL0          3
   SL1          -
   SLA          -
   SLX          -
   SR0          2
   SR1          -
   SRA          -
   SRX          -
   STORE        53
   SUB          8
   SUBCY        3
   TEST         7
   XOR          -
